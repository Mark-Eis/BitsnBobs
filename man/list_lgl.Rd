% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/logical-cols.R
\name{list_lgl}
\alias{list_lgl}
\title{Split Data Frame into a List Based on Values in Logical Columns}
\usage{
list_lgl(.data, ...)
}
\arguments{
\item{.data}{a data frame, or a data frame extension (e.g. a \code{\link[tibble:tibble-package]{tibble}}).}

\item{\dots}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> The selection of columns in \code{data} to be included in
the tibbles comprising elements of the returned list.}
}
\value{
A named list of \link[tibble:tibble-package]{tibble} data frames containing selected rows and columns of the
original data frame, having length equal to the number of logical columns in the original data frame and names the
same as the corresponding logical columns.
}
\description{
Split a data frame into a named \code{list} of \code{tibble} data frames on the basis that each new data frame forming
an element of the \code{list} comprises rows of the original data frame that contained \code{TRUE} values in
a particular \code{logical} column.
}
\details{
Columns of \code{data} to be included in \code{tibble}s comprising the list returned may be selected using the
\code{\dots} argument with the <\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> syntax of package \pkg{\link[dplyr]{dplyr}},
including use of \strong{selection helpers}. If this argument is omitted, all non-logical columns will be selected
using the tidy selection predicate function \code{\link[tidyselect]{where}(\(x) !\link[base]{is.logical}(x))}.

The length of the \code{list} returned is equal to the number of \code{logical} columns in the original data frame.
Each list element is named the same as the corresponding logical column in \code{data} from which rows with
\code{TRUE} values were selected for inclusion in its \code{tibble}.

\code{list_lgl()} may be used to tease out information in a character column of a data frame containing selected
keywords previously flagged in logical columns using \code{\link{kwd_cols}}, see examples. Finally, the named list
may be converted back to a single data frame using \code{\link[dplyr:bind_rows]{bind_rows}}, see examples.
}
\examples{
## Following on from kwd_cols() examplesâ€¦ 
car_names <- data.frame(Response = rownames(mtcars))
kwd <- c("Mazda", "Merc", "Toyota", "Volkswagen", "X", "450")
kwd_cols(car_names)<- kwd
car_names

list_lgl(car_names)
list_lgl(car_names, Response, X)
list_lgl(car_names, last_col())
list_lgl(car_names, contains("o"))

## Convert back to single data frame
car_names |>
  list_lgl() |>
  bind_rows(.id = "Group")

rm(kwd, car_names)
}
\seealso{
\code{\link[dplyr:bind_rows]{bind_rows}},  \code{\link[dplyr:select]{select}}, \code{\link[base:split]{split}},
<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}>, \code{\link[tibble:tibble-package]{tibble}}.

Other logical-cols: 
\code{\link{count_lgl}()},
\code{\link{kwd_cols}()}
}
\concept{logical-cols}
