% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detective.R
\name{detective}
\alias{detective}
\alias{detective<-}
\title{Search for Pattern in a Data Frame Character Column}
\usage{
detective(.data, pattern, ..., .exclude = NULL, .arrange_by = desc(n))

detective(.data, pattern, ..., .exclude = NULL) <- value
}
\arguments{
\item{.data}{a data frame, or a data frame extension (e.g. a \code{\link[tibble:tibble-package]{tibble}}).}

\item{pattern}{Pattern to look for.

The default interpretation is a regular expression, as described in
\code{vignette("regular-expressions")}. Use \code{\link[stringr:regex]{regex()}} for finer control of the
matching behaviour.

Match a fixed string (i.e. by comparing only bytes), using
\code{\link[stringr:fixed]{fixed()}}. This is fast, but approximate. Generally,
for matching human text, you'll want \code{\link[stringr:coll]{coll()}} which
respects character matching rules for the specified locale.

Match character, word, line and sentence boundaries with
\code{\link[stringr:boundary]{boundary()}}. An empty pattern, "", is equivalent to
\code{boundary("character")}.}

\item{\dots}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> \code{character} or \code{factor} columns to search and
return.}

\item{.exclude}{a single \code{character} string signifying items to be excluded, interpreted as for \code{pattern};
default \code{NULL}.}

\item{.arrange_by}{<\code{\link[rlang:args_data_masking]{data-masking}}> quoted name(s) of column(s) for ordering
results. Use \code{\link[dplyr:desc]{desc()}} to sort by variables in descending order; default \code{desc(n)}.}

\item{value}{a single \code{character} string providing the replacement value.}
}
\value{
\code{detective()} returns a \code{\link[tibble:tibble-package]{tibble}} with columns selected using \dots and
\code{n}, giving the count of occurences of each item.
}
\description{
Find and modify strings containing a specified pattern in a data frame character column.
}
\details{
\code{detective()} finds and counts strings matching \code{pattern} but not matching \code{.exclude} in selected
columns in \code{.data}, while \verb{detective()<-} is the equivalent replacement function. Both functions forms
allow use of the various possibilities for the \code{pattern} argument of \code{\link[stringr:str_detect]{str_detect}}.
Use \code{pattern = regex("xyz", ignore_case = TRUE)} for a case insensitive search. Use \pkg{\link[utils]{utils}}
package \code{\link[utils:glob2rx]{glob2rx()}} to change a wildcard or globbing pattern into a regular expression.

\code{character} or \code{factor} columns in \code{.data} are selected using \code{\dots} with the
<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> syntax of package \pkg{\link[dplyr]{dplyr}}, including use of
\strong{selection helpers}.

The output may be ordered by the values of selected columns using the syntax of \code{\link[dplyr:arrange]{arrange()}},
including use of \code{\link[dplyr:across]{across()}} or \code{\link[dplyr:pick]{pick()}} to select columns with
<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> (see examples).
}
\examples{
\dontshow{starwars <- (\() dplyr::starwars)()}

## Find strings containing a specified pattern in a data frame
starwars |> detective("Sky", name)

## Use regex() to make case insensitive
starwars |> detective(regex("WALKER", TRUE), name, .arrange_by = desc(name))

## Use | for alternatives
starwars |> detective("Sky|Organa", name)

## Replace strings containing a specified pattern
starwars |> detective("Darth", name)
starwars |> detective("Darth", name, .exclude = "Vader") <- "Darth The First"
starwars |> detective("Darth", name, .arrange_by = desc(name))

## Exclude strings containing unwanted patterns 
starwars |> detective("Sky", name, .exclude = "Luke")

## Return multiple columns 
starwars |> detective("Human", homeworld, species)
starwars |> detective("Human", homeworld, species, .exclude = "s")
starwars |> detective("Human", homeworld, species, .exclude = regex("s", TRUE))

## Select columns using <tidy-select> syntax from {dplyr},
## including use of “selection helpers”
starwars |> detective(
        "brown", contains("color"), species,
        .arrange_by = across(contains("color"))
    )

starwars |> detective(
        "brown", name, contains("color"), species,
        .exclude = "Human", .arrange_by = across(contains("color"))
    )

starwars |> detective(
        "brown", contains("color"), species,
    ) <- "chestnut"

starwars |> detective("brown", name, contains("color"), species)

starwars |> detective("chestnut", name, contains("color"), species)

## Use {utils} glob2rx() to create regular expression, in this instance 
## a wildcard * finding every character except a new line
starwars |> detective(glob2rx("*"), !c(name, contains("color")))

## Equivalent using {stringr} regex(".")
identical(
    starwars |> detective(glob2rx("*"), !c(name, contains("color"))),
    starwars |> detective(regex("."), !c(name, contains("color")))
)

## Equivalent using caret "^" in pattern string
identical(
    starwars |> detective(glob2rx("*"), !c(name, contains("color"))),
    starwars |> detective("^", !c(name, contains("color")))
)

\dontshow{rm(starwars)}

}
\seealso{
\code{\link[dplyr:across]{across()}}, \code{\link[dplyr:arrange]{arrange()}}, \code{\link[dplyr:desc]{desc()}},
\code{\link[utils:glob2rx]{glob2rx()}}, \code{\link[dplyr:pick]{pick()}} and \code{\link[stringr:str_detect]{str_detect()}}.

Other detective: 
\code{\link{retriever}()},
\code{\link{wizard}()}
}
\concept{detective}
