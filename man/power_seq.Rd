% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/powerseq.R
\name{power_seq}
\alias{power_seq}
\title{Expand Expression as a Power Sequence}
\usage{
power_seq(base_expr, n, type = c("simple", "evaluate", "replicate"))
}
\arguments{
\item{base_expr}{a bare (quoted) expression, see examples.}

\item{n}{a non-negative integer or number coercible into a positive integer.}

\item{type}{a character string, (partially) matching one of \code{"simple"}, \code{"evaluate"} or \code{"replicate"};
default \code{"simple"}.}
}
\value{
A \code{"call"} object i.e., a captured function call, possibly nested \var{n} times.
}
\description{
Create a power sequence from an expression, \var{base_expr}, and the maximum power number, \var{n}.
}
\details{
The power sequence is returned as a \code{"call"} object, which may be evaluated using \code{\link[rlang]{eval_tidy}}
in package \pkg{\link[rlang]{rlang}}, see examples. By default, \code{power_seq()} returns a simple \code{call}
object containing just one instance of both \var{base_expr} and \var{n}.

Alternatively, if \var{type} is \code{"evaluate"}, \code{power_seq()} evaluates \var{base_expr} and assigns the result
to a constant nested \var{n} times within the \code{call} object to be returned. This results in \var{base_expr} being
evaluated on execution of \code{power_seq()} rather than on evaluation of the returned call, which may be preferable
for more complex expressions.

Finally, if \var{type} is \code{"replicate"}, \code{power_seq()} captures the \var{base_expr} argument and its
environment as a \code{\link[rlang]{quosure}} to be replicated \var{n} times within the returned nested \code{call}
object. This results in \var{base_expr} being evaluated \var{n} times on evaluation of the returned call; this multiple
evaluation may be acceptable in simple cases but might be slow and inefficient for complex expressions.
}
\examples{
pseq <- power_seq(a + b, 3) |> print()
## pseq is a "call" object
typeof(pseq)
class(pseq)
mode(pseq)
is.call(pseq)
as.list(pseq)
is.call(pseq[[2]])
as.list(pseq[[2]])
is.call(pseq[[2]][[3]])
as.list(pseq[[2]][[3]])

## View the abstract syntax tree - requires {lobstr} package
if (!requireNamespace("lobstr", quietly = TRUE)) 
  warning("package 'lobstr' must be installed")
try(lobstr::ast(!!pseq))

## Or without !! (injection operator) by using the unexported function lobstr::ast_tree()
try(astree <- get("ast_tree", asNamespace("lobstr"), inherits = FALSE))

## …and setting the class attribute to "lobstr_raw", which attribute evokes print.lobstr_raw()
try(astree(pseq) |> structure(class = "lobstr_raw"))

## or by formatting output directly using paste() and cat()
try(astree(pseq) |> paste("\n", collapse = "") |> cat(sep = ""))

#######
pseq2 <- power_seq(log(x), 5) |> print()

x <- 3
eval_tidy(pseq2)  ## Uses x from the global environment

x <- 5
eval_tidy(pseq2)

rm(x)
try(eval_tidy(pseq2))

foo <- function() {
  x <- 10
  power_seq(log(x), 5)
}

pseq2 <- foo()
pseq2                 ## Expression looks just the same but …

x <- 3
eval_tidy(pseq2)  ## Consistently uses x from the environment of foo()

x <- 5
eval_tidy(pseq2)

rm(x)
eval_tidy(pseq2)


## Wrapper for log() reporting its execution using marker()
log <- function(...) {
  marker(msg = "in BitsnBobs Help")
  base::log(...)
}

## Compare the three options for type 
## log() invoked just once, on execution of power_seq() with type = "evaluate"
expr_ls <- c("simple", "evaluate", "replicate") |> setNames(nm = _) |>
    map(\(x) power_seq(log(3), 5, x)) |> print()

## log() invoked once on evaluation of expression from power_seq() with type = "simple" and
## five times on evaluation of expression from power_seq() with type = "replicate"
res_ls <- expr_ls |> map(eval_tidy) |> print()

## All three types evaluate identically: -
all(
  identical(res_ls[[1]], res_ls[[2]]),
  identical(res_ls[[1]], res_ls[[3]]),
  identical(res_ls[[2]], res_ls[[3]])
)

## Compare the three abstract syntax trees
try(expr_ls |> map(\(x) lobstr::ast(!!x)))
try(expr_ls |> map(astree)) |> map(structure, class = "lobstr_raw")

rm(astree, expr_ls, foo, log, pseq, pseq2, res_ls)
}
\seealso{
\code{\link{call}}, \code{\link[rlang]{eval_tidy}} and \code{\link[rlang]{quosure}}.

Other powerseq: 
\code{\link{formul_pwrseq}()}
}
\concept{powerseq}
